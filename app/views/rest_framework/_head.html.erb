<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<%= csrf_meta_tags %>
<%= csp_meta_tag rescue nil %>

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-aFq/bzH65dt+w6FI2ooMVUpc+21e0SRygnTpmBvdBgSdnuTN7QbdgL+OapgHtvPp" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha2/dist/js/bootstrap.bundle.min.js" integrity="sha384-qKXV1j0HvMUeCBQ+QVp7JcfGl760yU08IQ+GpUo5hlbpg51QRiuqHAJz8+BrxE/N" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.4/font/bootstrap-icons.css">

<!-- Highlight.js -->
<link rel="stylesheet" class="rrfLightMode" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/a11y-light.min.css" integrity="sha512-WDk6RzwygsN9KecRHAfm9HTN87LQjqdygDmkHSJxVkVI7ErCZ8ZWxP6T8RvBujY1n2/E4Ac+bn2ChXnp5rnnHA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" class="rrfDarkMode" disabled="disabled" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/a11y-dark.min.css" integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js" integrity="sha512-bgHRAiTjGrzHzLyKOnpFvaEpGzJet3z4tZnXGjpsCcqOnAH6VGUx9frc5bcIhKTVLEiCO6vEhNAgx5jtLUYrfA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/json.min.js" integrity="sha512-0xYvyncS9OLE7GOpNBZFnwyh9+bq4HVgk4yVVYI678xRvE22ASicF1v6fZ1UiST+M6pn17MzFZdvVCI3jTHSyw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/xml.min.js" integrity="sha512-5zBcw+OKRkaNyvUEPlTSfYylVzgpi7KpncY36b0gRudfxIYIH0q0kl2j26uCUB3YBRM6ytQQEZSgRg+ZlBTmdA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- NeatJSON -->
<script src="https://cdn.jsdelivr.net/npm/neatjson@0.10.5/javascript/neatjson.min.js"></script>

<!-- Trix -->
<link rel="stylesheet" type="text/css" href="https://unpkg.com/trix@2.0.0/dist/trix.css">
<script type="text/javascript" src="https://unpkg.com/trix@2.0.0/dist/trix.umd.min.js"></script>

<!-- Custom Style -->
<style>
/* Adjust headers to always take up their entire row, and tweak the sizing. */
h1,h2,h3,h4,h5,h6 { display: inline-block; font-weight: normal; margin-bottom: 0; }
h1 { font-size: 2rem; }
h2 { font-size: 1.7rem; }
h3 { font-size: 1.5rem; }
h4 { font-size: 1.3rem; }
h5 { font-size: 1.1rem; }
h6 { font-size: 1rem; }

/* Make code and code blocks a little nicer looking. */
pre code {
  display: block;
  overflow-x: auto;
}
code {
  padding: .5em !important;
  background-color: #eee !important;
  border: 1px solid #aaa;
  border-radius: 3px;
}
html[data-bs-theme="dark"] code {
  background-color: #2b2b2b !important;
}

/* Reduce label font size. */
label.form-label {
  font-size: .8em;
}

trix-editor:empty:not(:focus)::before {
  pointer-events: none;
}

/* Make Trix buttons visible even in dark mode. */
trix-toolbar .trix-button-group {
  background-color: #eee;
}

/* Make route group expansion obvious to the user. */
.rrf-routes .rrf-route-group-header:hover {
  background-color: #ddd;
}
html[data-bs-theme="dark"] .rrf-routes .rrf-route-group-header:hover {
  background-color: #333;
}
.rrf-routes .rrf-route-group-header td {
  cursor: pointer;
}

/* Disable bootstrap's collapsing animation because in tables it causes delayed jerkiness. */
.rrf-routes .collapsing {
  -webkit-transition: none;
  transition: none;
  display: none;
}

/* Copy-to-clipboard styles. */
.rrf-copy {
  position: relative;
}
.rrf-copy .rrf-copy-link {
  position: absolute;
  top: .5em;
  right: .5em;
  transition: 0.3s ease;
}
.rrf-copy .rrf-copy-link.rrf-clicked{
  color: green;
}
</style>

<!-- Custom JavaScript -->
<script>
// Get the real mode from a selected mode. Anything other than "light" or "dark" is treated as
// "system" mode.
function rrfGetRealMode(selectedMode) {
  if (selectedMode === "light" || selectedMode === "dark") {
    return selectedMode
  }

  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    return "dark"
  }

  return "light"
}

// Set the mode, given a "selected" mode.
function rrfSetSelectedMode(selectedMode) {
  const modeComponent = document.getElementById("rrfModeComponent")

  // Anything except "light" or "dark" is casted to "system".
  if (selectedMode !== "light" && selectedMode !== "dark") {
    selectedMode = "system"
  }

  // Store selected mode in `localStorage`.
  localStorage.setItem("rrfMode", selectedMode)

  // Set the mode selector to the selected mode.
  let labelNode
  modeComponent.querySelectorAll("button[data-mode-value]").forEach((el) => {
    if (el.getAttribute("data-mode-value") === selectedMode) {
      el.classList.add("active")
      labelNode = el.querySelector("i").cloneNode(true)
    } else {
      el.classList.remove("active")
    }
  })
  const primaryButton = modeComponent.querySelector("button[data-bs-toggle]")
  primaryButton.innerHTML = ""
  primaryButton.appendChild(labelNode)

  // Get the real mode to use.
  realMode = rrfGetRealMode(selectedMode)

  // Set the `realMode` effects.
  if (realMode === "light") {
    document.querySelectorAll(".rrfLightMode").forEach((el) => { el.disabled = false })
    document.querySelectorAll(".rrfDarkMode").forEach((el) => { el.disabled = true })
    document.documentElement.setAttribute("data-bs-theme", "light")
  } else if (realMode === "dark") {
    document.querySelectorAll(".rrfLightMode").forEach((el) => { el.disabled = true })
    document.querySelectorAll(".rrfDarkMode").forEach((el) => { el.disabled = false })
    document.documentElement.setAttribute("data-bs-theme", "dark")
  } else {
    console.log(`RRF: Unknown mode: ${mode}`)
  }
}

// What to do when document loads.
document.addEventListener("DOMContentLoaded", (event) => {
  // Initialize mode and create selector onclick events.
  const selectedMode = localStorage.getItem("rrfMode")
  rrfSetSelectedMode(selectedMode)
  document.querySelectorAll("#rrfModeComponent button[data-mode-value]").forEach((el) => {
    el.addEventListener("click", (event) => {
      rrfSetSelectedMode(event.target.getAttribute("data-mode-value"))
    })
  })

  // Pretty-print JSON.
  document.querySelectorAll(".language-json").forEach((el, index) => {
    el.innerHTML = neatJSON(JSON.parse(el.innerText), {
      wrap: 80,
      afterComma: 1,
      afterColon: 1,
    }).replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;")
  })

  // Then highlight it.
  hljs.configure({cssSelector: "pre code.auto-hljs"})
  hljs.highlightAll()

  // Replace text node links with anchor tag links.
  document.querySelectorAll(".rrf-copy code").forEach((el, index) => {
    el.innerHTML = rrfLinkify(el.innerHTML)
  })

  // Insert copy link and callback to copy contents of `<code>` element.
  document.querySelectorAll("rrf-copy").forEach((el, index) => {
    el.insertAdjacentHTML(
      "afterbegin",
      "<a class=\"rrf-copy-link\" onclick=\"return rrfCopyToClipboard(this)\" href=\"#\">Copy to Clipboard</a>",
    )
  })
})

// Convert plain-text links to anchor tag links.
function rrfLinkify(text) {
  return text.replace(/(https?:\/\/[^\s<>"]+)/g, "<a href=\"$1\" target=\"_blank\">$1</a>")
}

// Replace the document when doing form submission (mainly to support PUT/PATCH/DELETE).
function rrfReplaceDocument(content) {
  // Replace the document with provided content.
  document.open()
  document.write(content)
  document.close()

  // Trigger `DOMContentLoaded` manually so our custom JavaScript works.
  document.dispatchEvent(new Event("DOMContentLoaded", {bubbles: true, cancelable: true}))
}

// Copy the element's next `<code>` sibling's content to the clipboard.
function rrfCopyToClipboard(element) {
  let range = document.createRange()
  range.selectNode(element.nextSibling)
  window.getSelection().removeAllRanges()
  window.getSelection().addRange(range)
  if (document.execCommand("copy")) {
    // Trigger clicked animation.
    element.classList.add("rrf-clicked")
    element.innerText = "Copied!"
    setTimeout(() => {
      element.classList.remove("rrf-clicked")
      element.innerText = "Copy to Clipboard"
    }, 700)
  }

  // Return false to prevent normal link behavior.
  return false
}

// Refresh the window as a `GET` request.
function rrfGet(button) {
  button.disabled = true
  window.location.replace(window.location.href)
}

// Call `DELETE` on the current path.
function rrfDelete(button) {
  button.disabled = true
  rrfAPICall(window.location.pathname, "DELETE")
}

// Call `OPTIONS` on the current path.
function rrfOptions(button) {
  button.disabled = true
  rrfAPICall(window.location.pathname, "OPTIONS")
}

// Submit the raw form.
function rrfSubmitRawForm(button) {
  button.disabled = true

  // Grab the selected route/method, media type, and the body.
  const [method, path] = document.getElementById("rawFormRoute").value.split(":")
  const mediaType = document.getElementById("rawFormMediaType").value
  let body = document.getElementById("rawFormContent").value

  // If the media type is `multipart/form-data`, then we need to build a FormData object.
  if (mediaType == "multipart/form-data") {
    let formData = new FormData()

    // Add body to `formData`.
    const bodySearchParams = new URLSearchParams(body)
    bodySearchParams.forEach((value, key) => {
      formData.append(key, value)
    })

    // Add file(s) to `formData`.
    const rawFilesForm = document.getElementById("rawFilesForm")
    if (rawFilesForm) {
      rawFilesForm.querySelectorAll("input[type=file]").forEach((el, index) => {
        const files = el.files
        for (let i = 0; i < files.length; i++) {
          formData.append(el.name, files[i])
        }
      })
    }

    // Set body to be the form data.
    body = formData
  }

  // Perform the API call.
  rrfAPICall(path, method, {
    body,
    // If the media type is `multipart/form-data`, then we don't want to set the content type
    // because it must be set by `fetch` to include boundary.
    headers: mediaType == "multipart/form-data" ? {} : {"Content-Type": mediaType},
  })
}

// Make an HTML API call and replace the document with the response.
function rrfAPICall(path, method, kwargs={}) {
  const headers = kwargs.headers || {}
  delete kwargs.headers

  fetch(path, {method, headers: {"Accept": "text/html", ...headers}, ...kwargs})
    .then((response) => response.text())
    .then((body) => { rrfReplaceDocument(body) })
}

// Check if `rawFilesFormWrapper` should be displayed when media type is changed.
function rrfCheckRawFilesFormDisplay(el) {
  const rawFilesFormWrapper = document.getElementById("rawFilesFormWrapper")

  if (rawFilesFormWrapper) {
    if (el.value === "multipart/form-data") {
      rawFilesFormWrapper.style.display = "block"
    } else {
      rawFilesFormWrapper.style.display = "none"
    }
  }
}
</script>
